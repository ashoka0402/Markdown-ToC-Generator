#!/usr/bin/env python3
import argparse
import string
from pathlib import Path
from typing import Dict, Tuple, Optional

def read_file(file_name: str) -> Optional[str]:
    """Reads the file content and returns it as a string."""
    try:
        return Path(file_name).read_text(encoding='utf-8')
    except Exception as e:
        print(f"Error reading {file_name}: {e}")
        return None

def extract_headings(content: str, max_depth: int) -> Dict[str, int]:
    """Extracts headings up to max_depth level from markdown content."""
    headings = {}
    in_code_block, first_heading = False, True

    for line in content.splitlines():
        if line.startswith("```"):
            in_code_block = not in_code_block
        elif line.startswith("#") and not in_code_block:
            if first_heading or "table of contents" in line.lower():
                first_heading = False
                continue
            level = len(line) - len(line.lstrip("#"))
            if level <= max_depth:
                headings[line[level:].strip()] = level

    return headings

def format_heading(heading: str) -> str:
    """Formats a heading for ToC linking."""
    formatted = f"- [{heading}](#{''.join(['-' if c == ' ' else c.lower() for c in heading if c.isalnum() or c in ' &'])})\n"
    return formatted.replace(" & ", "--")

def generate_toc(headings: Dict[str, int]) -> str:
    """Generates a ToC from extracted headings based on their nesting levels."""
    toc = "### Table of Contents\n"
    indent = 0
    previous_level = min(headings.values(), default=0)

    for heading, level in headings.items():
        indent += max(0, level - previous_level)
        indent = max(0, indent - (previous_level - level))
        toc += "    " * indent + format_heading(heading)
        previous_level = level

    return toc

def find_toc_bounds(lines: list) -> Tuple[int, int]:
    """Finds the bounds of an existing ToC in lines if present."""
    start, end = -1, -1
    for i, line in enumerate(lines):
        if "<!--startofmdtoc-->" in line.lower():
            start = i
        elif "<!--endofmdtoc-->" in line.lower() and start != -1:
            end = i
            break
    return start, end

def insert_toc(toc_text: str, file_name: str) -> bool:
    """Inserts or replaces the ToC in the file between specified comments."""
    lines = read_file(file_name).splitlines()
    start, end = find_toc_bounds(lines)
    if start == -1 or end == -1:
        print("ToC markers not found.")
        return False

    lines[start:end + 1] = ["<!-- START OF MDTOC -->", toc_text, "<!-- END OF MDTOC -->"]
    Path(file_name).write_text('\n'.join(lines), encoding='utf-8')
    return True

def parse_arguments() -> Optional[Tuple[str, str, int]]:
    """Parses command-line arguments for the script."""
    parser = argparse.ArgumentParser(description='Generates a Table of Contents for a markdown file')
    parser.add_argument('source', help="Source markdown file")
    parser.add_argument('dest', help="Destination markdown file")
    parser.add_argument('-d', '--depth', type=int, default=6, help="Max heading depth")
    args = parser.parse_args()

    if not args.source.endswith(".md") or not args.dest.endswith(".md"):
        print("Source and destination files must be markdown files.")
        return None
    if not 1 <= args.depth <= 6:
        print("Depth must be between 1 and 6.")
        return None

    return args.source, args.dest, args.depth

def main() -> None:
    """Main function to run the ToC generator."""
    args = parse_arguments()
    if not args:
        return

    source, dest, depth = args
    markdown = read_file(source)
    if not markdown:
        return

    headings = extract_headings(markdown, depth)
    toc = generate_toc(headings)

    if insert_toc(toc, dest):
        print(f"Table of Contents successfully added to {dest}")

if __name__ == "__main__":
    main()
